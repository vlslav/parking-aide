package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/vlslav/parking-aide/internal/app/handlers.storage -o ./internal/app/handlers/mocks/storage_mock.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	db_storage "github.com/vlslav/parking-aide/internal/pkg/db-storage"
)

// StorageMock implements handlers.storage
type StorageMock struct {
	t minimock.Tester

	funcGetUser          func(ctx context.Context, userID int64) (up1 *db_storage.User, err error)
	inspectFuncGetUser   func(ctx context.Context, userID int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mStorageMockGetUser

	funcGetUserLocation          func(ctx context.Context, userID int64) (up1 *db_storage.UserLocation, err error)
	inspectFuncGetUserLocation   func(ctx context.Context, userID int64)
	afterGetUserLocationCounter  uint64
	beforeGetUserLocationCounter uint64
	GetUserLocationMock          mStorageMockGetUserLocation

	funcSaveUser          func(ctx context.Context, user *db_storage.User) (err error)
	inspectFuncSaveUser   func(ctx context.Context, user *db_storage.User)
	afterSaveUserCounter  uint64
	beforeSaveUserCounter uint64
	SaveUserMock          mStorageMockSaveUser

	funcSaveUserLocation          func(ctx context.Context, userLocation *db_storage.UserLocation) (err error)
	inspectFuncSaveUserLocation   func(ctx context.Context, userLocation *db_storage.UserLocation)
	afterSaveUserLocationCounter  uint64
	beforeSaveUserLocationCounter uint64
	SaveUserLocationMock          mStorageMockSaveUserLocation
}

// NewStorageMock returns a mock for handlers.storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUserMock = mStorageMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*StorageMockGetUserParams{}

	m.GetUserLocationMock = mStorageMockGetUserLocation{mock: m}
	m.GetUserLocationMock.callArgs = []*StorageMockGetUserLocationParams{}

	m.SaveUserMock = mStorageMockSaveUser{mock: m}
	m.SaveUserMock.callArgs = []*StorageMockSaveUserParams{}

	m.SaveUserLocationMock = mStorageMockSaveUserLocation{mock: m}
	m.SaveUserLocationMock.callArgs = []*StorageMockSaveUserLocationParams{}

	return m
}

type mStorageMockGetUser struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetUserExpectation
	expectations       []*StorageMockGetUserExpectation

	callArgs []*StorageMockGetUserParams
	mutex    sync.RWMutex
}

// StorageMockGetUserExpectation specifies expectation struct of the storage.GetUser
type StorageMockGetUserExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetUserParams
	results *StorageMockGetUserResults
	Counter uint64
}

// StorageMockGetUserParams contains parameters of the storage.GetUser
type StorageMockGetUserParams struct {
	ctx    context.Context
	userID int64
}

// StorageMockGetUserResults contains results of the storage.GetUser
type StorageMockGetUserResults struct {
	up1 *db_storage.User
	err error
}

// Expect sets up expected params for storage.GetUser
func (mmGetUser *mStorageMockGetUser) Expect(ctx context.Context, userID int64) *mStorageMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &StorageMockGetUserExpectation{}
	}

	mmGetUser.defaultExpectation.params = &StorageMockGetUserParams{ctx, userID}
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the storage.GetUser
func (mmGetUser *mStorageMockGetUser) Inspect(f func(ctx context.Context, userID int64)) *mStorageMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for StorageMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by storage.GetUser
func (mmGetUser *mStorageMockGetUser) Return(up1 *db_storage.User, err error) *StorageMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &StorageMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &StorageMockGetUserResults{up1, err}
	return mmGetUser.mock
}

//Set uses given function f to mock the storage.GetUser method
func (mmGetUser *mStorageMockGetUser) Set(f func(ctx context.Context, userID int64) (up1 *db_storage.User, err error)) *StorageMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the storage.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the storage.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// When sets expectation for the storage.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mStorageMockGetUser) When(ctx context.Context, userID int64) *StorageMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageMock.GetUser mock is already set by Set")
	}

	expectation := &StorageMockGetUserExpectation{
		mock:   mmGetUser.mock,
		params: &StorageMockGetUserParams{ctx, userID},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up storage.GetUser return parameters for the expectation previously defined by the When method
func (e *StorageMockGetUserExpectation) Then(up1 *db_storage.User, err error) *StorageMock {
	e.results = &StorageMockGetUserResults{up1, err}
	return e.mock
}

// GetUser implements handlers.storage
func (mmGetUser *StorageMock) GetUser(ctx context.Context, userID int64) (up1 *db_storage.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, userID)
	}

	mm_params := &StorageMockGetUserParams{ctx, userID}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_got := StorageMockGetUserParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("StorageMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the StorageMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, userID)
	}
	mmGetUser.t.Fatalf("Unexpected call to StorageMock.GetUser. %v %v", ctx, userID)
	return
}

// GetUserAfterCounter returns a count of finished StorageMock.GetUser invocations
func (mmGetUser *StorageMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of StorageMock.GetUser invocations
func (mmGetUser *StorageMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mStorageMockGetUser) Calls() []*StorageMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*StorageMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetUserDone() bool {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserInspect logs each unmet expectation
func (m *StorageMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetUser")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetUser")
	}
}

type mStorageMockGetUserLocation struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetUserLocationExpectation
	expectations       []*StorageMockGetUserLocationExpectation

	callArgs []*StorageMockGetUserLocationParams
	mutex    sync.RWMutex
}

// StorageMockGetUserLocationExpectation specifies expectation struct of the storage.GetUserLocation
type StorageMockGetUserLocationExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetUserLocationParams
	results *StorageMockGetUserLocationResults
	Counter uint64
}

// StorageMockGetUserLocationParams contains parameters of the storage.GetUserLocation
type StorageMockGetUserLocationParams struct {
	ctx    context.Context
	userID int64
}

// StorageMockGetUserLocationResults contains results of the storage.GetUserLocation
type StorageMockGetUserLocationResults struct {
	up1 *db_storage.UserLocation
	err error
}

// Expect sets up expected params for storage.GetUserLocation
func (mmGetUserLocation *mStorageMockGetUserLocation) Expect(ctx context.Context, userID int64) *mStorageMockGetUserLocation {
	if mmGetUserLocation.mock.funcGetUserLocation != nil {
		mmGetUserLocation.mock.t.Fatalf("StorageMock.GetUserLocation mock is already set by Set")
	}

	if mmGetUserLocation.defaultExpectation == nil {
		mmGetUserLocation.defaultExpectation = &StorageMockGetUserLocationExpectation{}
	}

	mmGetUserLocation.defaultExpectation.params = &StorageMockGetUserLocationParams{ctx, userID}
	for _, e := range mmGetUserLocation.expectations {
		if minimock.Equal(e.params, mmGetUserLocation.defaultExpectation.params) {
			mmGetUserLocation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserLocation.defaultExpectation.params)
		}
	}

	return mmGetUserLocation
}

// Inspect accepts an inspector function that has same arguments as the storage.GetUserLocation
func (mmGetUserLocation *mStorageMockGetUserLocation) Inspect(f func(ctx context.Context, userID int64)) *mStorageMockGetUserLocation {
	if mmGetUserLocation.mock.inspectFuncGetUserLocation != nil {
		mmGetUserLocation.mock.t.Fatalf("Inspect function is already set for StorageMock.GetUserLocation")
	}

	mmGetUserLocation.mock.inspectFuncGetUserLocation = f

	return mmGetUserLocation
}

// Return sets up results that will be returned by storage.GetUserLocation
func (mmGetUserLocation *mStorageMockGetUserLocation) Return(up1 *db_storage.UserLocation, err error) *StorageMock {
	if mmGetUserLocation.mock.funcGetUserLocation != nil {
		mmGetUserLocation.mock.t.Fatalf("StorageMock.GetUserLocation mock is already set by Set")
	}

	if mmGetUserLocation.defaultExpectation == nil {
		mmGetUserLocation.defaultExpectation = &StorageMockGetUserLocationExpectation{mock: mmGetUserLocation.mock}
	}
	mmGetUserLocation.defaultExpectation.results = &StorageMockGetUserLocationResults{up1, err}
	return mmGetUserLocation.mock
}

//Set uses given function f to mock the storage.GetUserLocation method
func (mmGetUserLocation *mStorageMockGetUserLocation) Set(f func(ctx context.Context, userID int64) (up1 *db_storage.UserLocation, err error)) *StorageMock {
	if mmGetUserLocation.defaultExpectation != nil {
		mmGetUserLocation.mock.t.Fatalf("Default expectation is already set for the storage.GetUserLocation method")
	}

	if len(mmGetUserLocation.expectations) > 0 {
		mmGetUserLocation.mock.t.Fatalf("Some expectations are already set for the storage.GetUserLocation method")
	}

	mmGetUserLocation.mock.funcGetUserLocation = f
	return mmGetUserLocation.mock
}

// When sets expectation for the storage.GetUserLocation which will trigger the result defined by the following
// Then helper
func (mmGetUserLocation *mStorageMockGetUserLocation) When(ctx context.Context, userID int64) *StorageMockGetUserLocationExpectation {
	if mmGetUserLocation.mock.funcGetUserLocation != nil {
		mmGetUserLocation.mock.t.Fatalf("StorageMock.GetUserLocation mock is already set by Set")
	}

	expectation := &StorageMockGetUserLocationExpectation{
		mock:   mmGetUserLocation.mock,
		params: &StorageMockGetUserLocationParams{ctx, userID},
	}
	mmGetUserLocation.expectations = append(mmGetUserLocation.expectations, expectation)
	return expectation
}

// Then sets up storage.GetUserLocation return parameters for the expectation previously defined by the When method
func (e *StorageMockGetUserLocationExpectation) Then(up1 *db_storage.UserLocation, err error) *StorageMock {
	e.results = &StorageMockGetUserLocationResults{up1, err}
	return e.mock
}

// GetUserLocation implements handlers.storage
func (mmGetUserLocation *StorageMock) GetUserLocation(ctx context.Context, userID int64) (up1 *db_storage.UserLocation, err error) {
	mm_atomic.AddUint64(&mmGetUserLocation.beforeGetUserLocationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserLocation.afterGetUserLocationCounter, 1)

	if mmGetUserLocation.inspectFuncGetUserLocation != nil {
		mmGetUserLocation.inspectFuncGetUserLocation(ctx, userID)
	}

	mm_params := &StorageMockGetUserLocationParams{ctx, userID}

	// Record call args
	mmGetUserLocation.GetUserLocationMock.mutex.Lock()
	mmGetUserLocation.GetUserLocationMock.callArgs = append(mmGetUserLocation.GetUserLocationMock.callArgs, mm_params)
	mmGetUserLocation.GetUserLocationMock.mutex.Unlock()

	for _, e := range mmGetUserLocation.GetUserLocationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserLocation.GetUserLocationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserLocation.GetUserLocationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserLocation.GetUserLocationMock.defaultExpectation.params
		mm_got := StorageMockGetUserLocationParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserLocation.t.Errorf("StorageMock.GetUserLocation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserLocation.GetUserLocationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserLocation.t.Fatal("No results are set for the StorageMock.GetUserLocation")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserLocation.funcGetUserLocation != nil {
		return mmGetUserLocation.funcGetUserLocation(ctx, userID)
	}
	mmGetUserLocation.t.Fatalf("Unexpected call to StorageMock.GetUserLocation. %v %v", ctx, userID)
	return
}

// GetUserLocationAfterCounter returns a count of finished StorageMock.GetUserLocation invocations
func (mmGetUserLocation *StorageMock) GetUserLocationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserLocation.afterGetUserLocationCounter)
}

// GetUserLocationBeforeCounter returns a count of StorageMock.GetUserLocation invocations
func (mmGetUserLocation *StorageMock) GetUserLocationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserLocation.beforeGetUserLocationCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetUserLocation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserLocation *mStorageMockGetUserLocation) Calls() []*StorageMockGetUserLocationParams {
	mmGetUserLocation.mutex.RLock()

	argCopy := make([]*StorageMockGetUserLocationParams, len(mmGetUserLocation.callArgs))
	copy(argCopy, mmGetUserLocation.callArgs)

	mmGetUserLocation.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserLocationDone returns true if the count of the GetUserLocation invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetUserLocationDone() bool {
	for _, e := range m.GetUserLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserLocationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserLocationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserLocation != nil && mm_atomic.LoadUint64(&m.afterGetUserLocationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserLocationInspect logs each unmet expectation
func (m *StorageMock) MinimockGetUserLocationInspect() {
	for _, e := range m.GetUserLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetUserLocation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserLocationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserLocationCounter) < 1 {
		if m.GetUserLocationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetUserLocation")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetUserLocation with params: %#v", *m.GetUserLocationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserLocation != nil && mm_atomic.LoadUint64(&m.afterGetUserLocationCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetUserLocation")
	}
}

type mStorageMockSaveUser struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSaveUserExpectation
	expectations       []*StorageMockSaveUserExpectation

	callArgs []*StorageMockSaveUserParams
	mutex    sync.RWMutex
}

// StorageMockSaveUserExpectation specifies expectation struct of the storage.SaveUser
type StorageMockSaveUserExpectation struct {
	mock    *StorageMock
	params  *StorageMockSaveUserParams
	results *StorageMockSaveUserResults
	Counter uint64
}

// StorageMockSaveUserParams contains parameters of the storage.SaveUser
type StorageMockSaveUserParams struct {
	ctx  context.Context
	user *db_storage.User
}

// StorageMockSaveUserResults contains results of the storage.SaveUser
type StorageMockSaveUserResults struct {
	err error
}

// Expect sets up expected params for storage.SaveUser
func (mmSaveUser *mStorageMockSaveUser) Expect(ctx context.Context, user *db_storage.User) *mStorageMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("StorageMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &StorageMockSaveUserExpectation{}
	}

	mmSaveUser.defaultExpectation.params = &StorageMockSaveUserParams{ctx, user}
	for _, e := range mmSaveUser.expectations {
		if minimock.Equal(e.params, mmSaveUser.defaultExpectation.params) {
			mmSaveUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUser.defaultExpectation.params)
		}
	}

	return mmSaveUser
}

// Inspect accepts an inspector function that has same arguments as the storage.SaveUser
func (mmSaveUser *mStorageMockSaveUser) Inspect(f func(ctx context.Context, user *db_storage.User)) *mStorageMockSaveUser {
	if mmSaveUser.mock.inspectFuncSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveUser")
	}

	mmSaveUser.mock.inspectFuncSaveUser = f

	return mmSaveUser
}

// Return sets up results that will be returned by storage.SaveUser
func (mmSaveUser *mStorageMockSaveUser) Return(err error) *StorageMock {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("StorageMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &StorageMockSaveUserExpectation{mock: mmSaveUser.mock}
	}
	mmSaveUser.defaultExpectation.results = &StorageMockSaveUserResults{err}
	return mmSaveUser.mock
}

//Set uses given function f to mock the storage.SaveUser method
func (mmSaveUser *mStorageMockSaveUser) Set(f func(ctx context.Context, user *db_storage.User) (err error)) *StorageMock {
	if mmSaveUser.defaultExpectation != nil {
		mmSaveUser.mock.t.Fatalf("Default expectation is already set for the storage.SaveUser method")
	}

	if len(mmSaveUser.expectations) > 0 {
		mmSaveUser.mock.t.Fatalf("Some expectations are already set for the storage.SaveUser method")
	}

	mmSaveUser.mock.funcSaveUser = f
	return mmSaveUser.mock
}

// When sets expectation for the storage.SaveUser which will trigger the result defined by the following
// Then helper
func (mmSaveUser *mStorageMockSaveUser) When(ctx context.Context, user *db_storage.User) *StorageMockSaveUserExpectation {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("StorageMock.SaveUser mock is already set by Set")
	}

	expectation := &StorageMockSaveUserExpectation{
		mock:   mmSaveUser.mock,
		params: &StorageMockSaveUserParams{ctx, user},
	}
	mmSaveUser.expectations = append(mmSaveUser.expectations, expectation)
	return expectation
}

// Then sets up storage.SaveUser return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveUserExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSaveUserResults{err}
	return e.mock
}

// SaveUser implements handlers.storage
func (mmSaveUser *StorageMock) SaveUser(ctx context.Context, user *db_storage.User) (err error) {
	mm_atomic.AddUint64(&mmSaveUser.beforeSaveUserCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUser.afterSaveUserCounter, 1)

	if mmSaveUser.inspectFuncSaveUser != nil {
		mmSaveUser.inspectFuncSaveUser(ctx, user)
	}

	mm_params := &StorageMockSaveUserParams{ctx, user}

	// Record call args
	mmSaveUser.SaveUserMock.mutex.Lock()
	mmSaveUser.SaveUserMock.callArgs = append(mmSaveUser.SaveUserMock.callArgs, mm_params)
	mmSaveUser.SaveUserMock.mutex.Unlock()

	for _, e := range mmSaveUser.SaveUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveUser.SaveUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUser.SaveUserMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUser.SaveUserMock.defaultExpectation.params
		mm_got := StorageMockSaveUserParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUser.t.Errorf("StorageMock.SaveUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUser.SaveUserMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUser.t.Fatal("No results are set for the StorageMock.SaveUser")
		}
		return (*mm_results).err
	}
	if mmSaveUser.funcSaveUser != nil {
		return mmSaveUser.funcSaveUser(ctx, user)
	}
	mmSaveUser.t.Fatalf("Unexpected call to StorageMock.SaveUser. %v %v", ctx, user)
	return
}

// SaveUserAfterCounter returns a count of finished StorageMock.SaveUser invocations
func (mmSaveUser *StorageMock) SaveUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.afterSaveUserCounter)
}

// SaveUserBeforeCounter returns a count of StorageMock.SaveUser invocations
func (mmSaveUser *StorageMock) SaveUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.beforeSaveUserCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUser *mStorageMockSaveUser) Calls() []*StorageMockSaveUserParams {
	mmSaveUser.mutex.RLock()

	argCopy := make([]*StorageMockSaveUserParams, len(mmSaveUser.callArgs))
	copy(argCopy, mmSaveUser.callArgs)

	mmSaveUser.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserDone returns true if the count of the SaveUser invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveUserDone() bool {
	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUser != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveUserInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveUserInspect() {
	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		if m.SaveUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SaveUser")
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveUser with params: %#v", *m.SaveUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUser != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SaveUser")
	}
}

type mStorageMockSaveUserLocation struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSaveUserLocationExpectation
	expectations       []*StorageMockSaveUserLocationExpectation

	callArgs []*StorageMockSaveUserLocationParams
	mutex    sync.RWMutex
}

// StorageMockSaveUserLocationExpectation specifies expectation struct of the storage.SaveUserLocation
type StorageMockSaveUserLocationExpectation struct {
	mock    *StorageMock
	params  *StorageMockSaveUserLocationParams
	results *StorageMockSaveUserLocationResults
	Counter uint64
}

// StorageMockSaveUserLocationParams contains parameters of the storage.SaveUserLocation
type StorageMockSaveUserLocationParams struct {
	ctx          context.Context
	userLocation *db_storage.UserLocation
}

// StorageMockSaveUserLocationResults contains results of the storage.SaveUserLocation
type StorageMockSaveUserLocationResults struct {
	err error
}

// Expect sets up expected params for storage.SaveUserLocation
func (mmSaveUserLocation *mStorageMockSaveUserLocation) Expect(ctx context.Context, userLocation *db_storage.UserLocation) *mStorageMockSaveUserLocation {
	if mmSaveUserLocation.mock.funcSaveUserLocation != nil {
		mmSaveUserLocation.mock.t.Fatalf("StorageMock.SaveUserLocation mock is already set by Set")
	}

	if mmSaveUserLocation.defaultExpectation == nil {
		mmSaveUserLocation.defaultExpectation = &StorageMockSaveUserLocationExpectation{}
	}

	mmSaveUserLocation.defaultExpectation.params = &StorageMockSaveUserLocationParams{ctx, userLocation}
	for _, e := range mmSaveUserLocation.expectations {
		if minimock.Equal(e.params, mmSaveUserLocation.defaultExpectation.params) {
			mmSaveUserLocation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUserLocation.defaultExpectation.params)
		}
	}

	return mmSaveUserLocation
}

// Inspect accepts an inspector function that has same arguments as the storage.SaveUserLocation
func (mmSaveUserLocation *mStorageMockSaveUserLocation) Inspect(f func(ctx context.Context, userLocation *db_storage.UserLocation)) *mStorageMockSaveUserLocation {
	if mmSaveUserLocation.mock.inspectFuncSaveUserLocation != nil {
		mmSaveUserLocation.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveUserLocation")
	}

	mmSaveUserLocation.mock.inspectFuncSaveUserLocation = f

	return mmSaveUserLocation
}

// Return sets up results that will be returned by storage.SaveUserLocation
func (mmSaveUserLocation *mStorageMockSaveUserLocation) Return(err error) *StorageMock {
	if mmSaveUserLocation.mock.funcSaveUserLocation != nil {
		mmSaveUserLocation.mock.t.Fatalf("StorageMock.SaveUserLocation mock is already set by Set")
	}

	if mmSaveUserLocation.defaultExpectation == nil {
		mmSaveUserLocation.defaultExpectation = &StorageMockSaveUserLocationExpectation{mock: mmSaveUserLocation.mock}
	}
	mmSaveUserLocation.defaultExpectation.results = &StorageMockSaveUserLocationResults{err}
	return mmSaveUserLocation.mock
}

//Set uses given function f to mock the storage.SaveUserLocation method
func (mmSaveUserLocation *mStorageMockSaveUserLocation) Set(f func(ctx context.Context, userLocation *db_storage.UserLocation) (err error)) *StorageMock {
	if mmSaveUserLocation.defaultExpectation != nil {
		mmSaveUserLocation.mock.t.Fatalf("Default expectation is already set for the storage.SaveUserLocation method")
	}

	if len(mmSaveUserLocation.expectations) > 0 {
		mmSaveUserLocation.mock.t.Fatalf("Some expectations are already set for the storage.SaveUserLocation method")
	}

	mmSaveUserLocation.mock.funcSaveUserLocation = f
	return mmSaveUserLocation.mock
}

// When sets expectation for the storage.SaveUserLocation which will trigger the result defined by the following
// Then helper
func (mmSaveUserLocation *mStorageMockSaveUserLocation) When(ctx context.Context, userLocation *db_storage.UserLocation) *StorageMockSaveUserLocationExpectation {
	if mmSaveUserLocation.mock.funcSaveUserLocation != nil {
		mmSaveUserLocation.mock.t.Fatalf("StorageMock.SaveUserLocation mock is already set by Set")
	}

	expectation := &StorageMockSaveUserLocationExpectation{
		mock:   mmSaveUserLocation.mock,
		params: &StorageMockSaveUserLocationParams{ctx, userLocation},
	}
	mmSaveUserLocation.expectations = append(mmSaveUserLocation.expectations, expectation)
	return expectation
}

// Then sets up storage.SaveUserLocation return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveUserLocationExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSaveUserLocationResults{err}
	return e.mock
}

// SaveUserLocation implements handlers.storage
func (mmSaveUserLocation *StorageMock) SaveUserLocation(ctx context.Context, userLocation *db_storage.UserLocation) (err error) {
	mm_atomic.AddUint64(&mmSaveUserLocation.beforeSaveUserLocationCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUserLocation.afterSaveUserLocationCounter, 1)

	if mmSaveUserLocation.inspectFuncSaveUserLocation != nil {
		mmSaveUserLocation.inspectFuncSaveUserLocation(ctx, userLocation)
	}

	mm_params := &StorageMockSaveUserLocationParams{ctx, userLocation}

	// Record call args
	mmSaveUserLocation.SaveUserLocationMock.mutex.Lock()
	mmSaveUserLocation.SaveUserLocationMock.callArgs = append(mmSaveUserLocation.SaveUserLocationMock.callArgs, mm_params)
	mmSaveUserLocation.SaveUserLocationMock.mutex.Unlock()

	for _, e := range mmSaveUserLocation.SaveUserLocationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveUserLocation.SaveUserLocationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUserLocation.SaveUserLocationMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUserLocation.SaveUserLocationMock.defaultExpectation.params
		mm_got := StorageMockSaveUserLocationParams{ctx, userLocation}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUserLocation.t.Errorf("StorageMock.SaveUserLocation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUserLocation.SaveUserLocationMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUserLocation.t.Fatal("No results are set for the StorageMock.SaveUserLocation")
		}
		return (*mm_results).err
	}
	if mmSaveUserLocation.funcSaveUserLocation != nil {
		return mmSaveUserLocation.funcSaveUserLocation(ctx, userLocation)
	}
	mmSaveUserLocation.t.Fatalf("Unexpected call to StorageMock.SaveUserLocation. %v %v", ctx, userLocation)
	return
}

// SaveUserLocationAfterCounter returns a count of finished StorageMock.SaveUserLocation invocations
func (mmSaveUserLocation *StorageMock) SaveUserLocationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserLocation.afterSaveUserLocationCounter)
}

// SaveUserLocationBeforeCounter returns a count of StorageMock.SaveUserLocation invocations
func (mmSaveUserLocation *StorageMock) SaveUserLocationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserLocation.beforeSaveUserLocationCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveUserLocation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUserLocation *mStorageMockSaveUserLocation) Calls() []*StorageMockSaveUserLocationParams {
	mmSaveUserLocation.mutex.RLock()

	argCopy := make([]*StorageMockSaveUserLocationParams, len(mmSaveUserLocation.callArgs))
	copy(argCopy, mmSaveUserLocation.callArgs)

	mmSaveUserLocation.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserLocationDone returns true if the count of the SaveUserLocation invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveUserLocationDone() bool {
	for _, e := range m.SaveUserLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserLocationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserLocationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserLocation != nil && mm_atomic.LoadUint64(&m.afterSaveUserLocationCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveUserLocationInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveUserLocationInspect() {
	for _, e := range m.SaveUserLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveUserLocation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserLocationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserLocationCounter) < 1 {
		if m.SaveUserLocationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SaveUserLocation")
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveUserLocation with params: %#v", *m.SaveUserLocationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserLocation != nil && mm_atomic.LoadUint64(&m.afterSaveUserLocationCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SaveUserLocation")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetUserInspect()

		m.MinimockGetUserLocationInspect()

		m.MinimockSaveUserInspect()

		m.MinimockSaveUserLocationInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUserDone() &&
		m.MinimockGetUserLocationDone() &&
		m.MinimockSaveUserDone() &&
		m.MinimockSaveUserLocationDone()
}
